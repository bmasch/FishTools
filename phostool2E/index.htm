<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<head>
<link rel="icon" type="image/gif" href="http://onefishtwofish.net/images/salmon_ico.gif">
<link rel="stylesheet" type="text/css" href="http://www.onefishtwofish.net/styles/fish.css" />
<link rel="stylesheet" type="text/css" href="../styles/tab_style.css" />
<title>HatchMark2E -- OneFishTwoFish</title>

<style>
div.info {
	width: 1000px;
	height: 820px;
	overflow:auto;	
	}
div.tabs {
	width: 1000px;
	}
div.info_text {
	overflow:auto;
	margin-left: 10px;
	margin-right: 10px;
	padding-left: 0px;
	padding-top: 0px;
	}
.users_guide_table {
font-family: arial, helvetica;
font-size: 10pt;
cursor: default;
margin: 0;
background: white;
border-spacing: 0;
padding: 5px;
}

.info_header {
	margin-top: 20px;
	font-family: arial, helvetica;
	font-size: 11pt;
	font-weight: bold;
}

p {
	font-family: arial, helvetica;
	font-size: 11pt;
}

			
</style>

<script src="../script/tabjs.js"></script>
<script src="../script/spry/SpryEffects.js" type="text/javascript"></script>
<script type="text/javascript">
  			
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-18774702-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  
</script>
</head>

<!-- without body tag IE may have unprodictable behaviours -->
<body bgcolor="#faff05">
<a href="http://www.onefishtwofish.net/" alt="OFTF Home"><img src="../images/logo_tagline2.jpg" border="0"></a>
<p><b>HatchMark2E: estimate proportion of multi-hatchery-origin escapement using generalized least squares</b></p>
<script>
var nojs=0;
</script>
<noscript>
<div>
<p style="{color: #ff0000;}"><b>To view the tool documentation, javascript needs to be enabled on your computer.</b></p>
<p>In Internet Explorer, select <i>Tools =&gt; Internet Options =&gt; Security =&gt; Custom</i>, scroll down to Scripting/Active Scripting, and set it to <b>Enable</b>. 
<p>In Firefox, select <i>Tools =&gt; Options =&gt; Content</i>, and ensure that <b>Enable Javascript</b> is checked.</p>
</div></noscript>
<div class="tabs">
	<table cellspacing="0" cellpadding="0">
		<tr bgcolor="#ffffff" id="one" style="{display: block;}">
		<td class="tab"><img src="../images/left1.gif"></td><td nowrap background="../images/back1.gif">&nbsp;Tool&nbsp;</TD><td><img src="../images/mid10.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab2'); setTabs('two');" class="tablink">&nbsp;Background&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab3'); setTabs('three');" class="tablink">&nbsp;User's Guide&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab4'); setTabs('four');" class="tablink">&nbsp;Credits&nbsp;</a></TD><td><img src="../images/right0.gif"></td>	
		</tr>

		<tr bgcolor="#ffffff" id="two" class="hide">
		<td class="tab"><img src="../images/left0.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab1'); setTabs('one');" class="tablink">&nbsp;Tool&nbsp;</a></TD><td><img src="../images/mid01.gif"></td><td nowrap background="../images/back1.gif">&nbsp;Background&nbsp;</TD><td><img src="../images/mid10.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab3'); setTabs('three');" class="tablink">&nbsp;User's Guide&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab4'); setTabs('four');" class="tablink">&nbsp;Credits&nbsp;</a></TD><td><img src="../images/right0.gif"></td>	
		</tr>
		<tr bgcolor="#ffffff" id="three" class="hide">
		<td class="tab"><img src="../images/left0.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab1'); setTabs('one');" class="tablink">&nbsp;Tool&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab2'); setTabs('two');" class="tablink">&nbsp;Background&nbsp;</a></TD><td><img src="../images/mid01.gif"></td><td nowrap background="../images/back1.gif">&nbsp;User's Guide&nbsp;</TD><td><img src="../images/mid10.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab4'); setTabs('four');" class="tablink">&nbsp;Credits&nbsp;</a></TD><td><img src="../images/right0.gif"></td>
		</tr>	
		<tr bgcolor="#ffffff" id="four" class="hide">
		<td class="tab"><img src="../images/left0.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab1'); setTabs('one');" class="tablink">&nbsp;Tool&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab2'); setTabs('two');" class="tablink">&nbsp;Background&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif">&nbsp;<a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab3'); setTabs('three');" class="tablink">User's Guide&nbsp;</a></TD><td><img src="../images/mid01.gif"></td><td nowrap background="../images/back1.gif">&nbsp;Credits&nbsp;</TD><td><img src="../images/right1.gif"></td>
		</tr>						
	</table>
</div>
<div class="info">
	<div style="display: inline;" id="tab1">
		<iframe src="http://ec2-54-176-167-218.us-west-1.compute.amazonaws.com/html/hatchmark2E_1.1.html" width="1000" height="810" frameborder="0" scrolling="no">
		You really need to enable iframes to use this tool...
		</iframe>
	</div>
<div class="hide" id="tab2">
	<div class="info_text">
		<p>This tool is used to estimate the numbers of hatchery- and wild-origin spawners, and the proportion of hatchery-origin spawners. This tool is used when different source hatcheries utilize different visible marking fractions.</p>
		<p><em>Disclaimer: This use of this tool is free and comes with absolutely no warranty.</em></p>
		<p><a href="http://www.onefishtwofish.net/phostool2E/documents/prop_hatchery_spawners3-06-13.pptx" target="_new">Alternative Estimators of the Proportion of Hatchery-Origin Spawners (1.2 MB ppt)</a></p>
		<p><a href="http://www.onefishtwofish.net/phostool2E/documents/Marking-webtool-mhatch2e-6-28-2012.pdf" target="_new">HATCHMARK2E: 
A statistical tool to estimate the proportion of hatchery-origin spawners using generalized least squares</a></p>
		<p>and can be reproduced with the following <strong>R</strong> code:</p>
		
<pre>
#HATCHMARK2E Program to estimate proportion of hatchery-origin escapement using
#generalized least squares (Hinrichsen et al. 2011). Precision results are obtained using
#Bootstrapping or theoretical results
#
#This code treats the general case of inputs from several source hatcheries with potentially 
#different visual marking fractions (VM fractions). 

#Variables and parameters used in the analysis
#inputs
#Nsims = total number of bootstrap replications
#x2 = visibly marked and not coded-wire tagged observation
#x1 = visibly marked and coded-wire tagged observations (hatchery-specific)
#Eu = Number of spawners in the sample that are not visibly marked
#theta = sampling fraction 
#lambda = marking rate (lambda)  (hatchery-specific)
#phi=fraction of marked fish that are also coded-wire tagged (hatchery-specific)
#
#output variables
#Nnos = GLSE estimate of natural origin spawning escapement
#Nhos = GLSE estimate of hatchery origin spawning escapement escapement (hatchery-specific)
#phos = GLSE estimate of the proportion of hatchery-origin spawning escapement
#SE.Nnoshat = standard error (SE) of Nnoshat
#CV.Nnoshat = Coefficient of variation of Nnoshat
#SE.Nhoshat = standard error (SE) of Nhoshat
#CV.Nhoshat = Coefficient of variation of Nhoshat
#SE.phoshat = standard error (SE) of the phos estimator
#CV.phoshat = Coefficient of variation of the phos estimator
#BIAS.phoshat = relative bias of the phos estimator

#the following use theoretical formulas

#SE2.Nnoshat = standard error (SE) of Nnoshat
#CV2.Nnoshat = Coefficient of variation of Nnoshat
#SE2.Nhoshat = standard error (SE) of Nhoshat
#CV2.Nhoshat = Coefficient of variation of Nhoshat
#SE2.phoshat = standard error (SE) 
#CV2.phoshat = Coefficient of variation 

#use bootstrapping for variance and bias
phos.mhatch.main1<-function(Nsims=10000,x1=c(40,23),x2=40,Eu=200,theta=0.25,
lambda=c(0.75,0.25),phi=c(.5,.9)){

#check inputs
k1<-length(x1);k2<-length(lambda);k3<-length(phi)
mytest<-abs(k1-k2)+abs(k2-k3)
if(mytest>0) stop("dimensions of x1, lambda, and phi must match")
nhatch<-length(x1)

if(theta>1)stop("theta must be less than or equal to one")
if(theta<=0)stop("theta must be greater than zero")
if(sum(lambda>1))stop("lambdas must all be less than one")
if(sum(lambda<=0))stop("lambdas must all be greater than zero")
if(sum(phi>1))stop("phis must all be less than one")
if(sum(phi<=0))stop("phis must all be greater than zero")


#check lambdas (if they are all the same, the analysis simplifies)
lambdatest<-FALSE
if(nhatch==1){lambdatest==TRUE}
if(nhatch>1){lambdatest<-var(lambda)<1.e-10}

if(lambdatest){
  Nhos<-(sum(x1)+x2)/(theta*lambda[1])
  Nnos<-(sum(x1)+x2+Eu)/theta - Nhos
  res1<-phos.estimates1(Nsims=Nsims, Nnos=Nnos,Nhos=Nhos,theta=theta,lambda=lambda[1])
}else{
if((sum(abs(x1))<1.e-10)&(x2>0))stop("Nhos unestimable because lambdas differ and x1=0 and x2>0")
phitest<-FALSE
if(sum(phi==1)==nhatch)phitest<-TRUE
if(!phitest){
Nhos<-get.nhoshat.all(x1=x1,x2=x2,theta=theta,lambda=lambda,phi=phi)
}else{
 if(x2>0)stop("Error: All phis are one and x2 is greater than zero")
 Nhos<-x1/(theta*lambda)
}
Nnos<-(sum(x1)+x2+Eu)/theta - sum(Nhos)

res1<-phos.mhatch.estimates1(Nsims=Nsims,Nnos=Nnos,Nhos=Nhos,theta=theta,
	lambda=lambda,phi=phi)
}

return(list(Nsims=res1$Nsims,
              x1=x1,
	      x2=x2,
	      Eu=Eu,
              theta=theta,
	      lambda=lambda,
	      phi=phi,
	      Nnos=res1$Nnos,
	      Nhos=sum(res1$Nhos),
	      phos=res1$phos,
              SE.Nnoshat=res1$SE.Nnoshat,
              CV.Nnoshat=res1$CV.Nnoshat,
              SE.Nhoshat=res1$SE.Nhoshat,
              CV.Nhoshat=res1$CV.Nhoshat,
              SE.phoshat=res1$SE.phoshat,
              CV.phoshat=res1$CV.phoshat,
              BIAS.phoshat=res1$BIAS.phoshat))

}

#use theoretical variances formulas
phos.mhatch.main2<-function(x1=c(40,23),x2=40,Eu=200,theta=0.25,
lambda=c(0.75,0.25),phi=c(.5,.9)){

#check inputs
k1<-length(x1);k2<-length(lambda);k3<-length(phi)
mytest<-abs(k1-k2)+abs(k2-k3)
if(mytest>0) stop("dimensions of x1, lambda, and phi must match")
nhatch<-length(x1)

if(theta>1)stop("theta must be less than or equal to one")
if(theta<=0)stop("theta must be greater than zero")
if(sum(lambda>1))stop("lambdas must all be less than one")
if(sum(lambda<=0))stop("lambdas must all be greater than zero")
if(sum(phi>1))stop("phis must all be less than one")
if(sum(phi<=0))stop("phis must all be greater than zero")


#check lambdas (if they are all the same, the analysis simplifies)
lambdatest<-FALSE
if(nhatch==1){lambdatest==TRUE}
if(nhatch>1){lambdatest<-var(lambda)<1.e-10}

if(lambdatest){
  Nhos<-(sum(x1)+x2)/(theta*lambda[1])
  Nnos<-(sum(x1)+x2+Eu)/theta - Nhos
  res2<-phos.estimates2(Nnos=Nnos,Nhos=Nhos,theta=theta,lambda=lambda[1])
}else{
if((sum(abs(x1))<1.e-10)&(x2>0))stop("Nhos unestimable because lambdas differ and x1=0 and x2>0")
phitest<-FALSE
if(sum(phi==1)==nhatch)phitest<-TRUE
if(!phitest){
Nhos<-get.nhoshat.all(x1=x1,x2=x2,theta=theta,lambda=lambda,phi=phi)
}else{
 if(x2>0)stop("Error: All phis are one and x2 is greater than zero")
 Nhos<-x1/(theta*lambda)
}

Nnos<-(sum(x1)+x2+Eu)/theta - sum(Nhos)
res2<-phos.mhatch.estimates2(Nnos=Nnos,Nhos=Nhos,theta=theta,
	lambda=lambda,phi=phi)
}

return(list(Nsims=NA,
            x1=x1,
	    x2=x2,
            Eu=Eu,
            theta=theta,
	    lambda=lambda,
            phi=phi,   
	    Nnos=res2$Nnos,
            Nhos=sum(res2$Nhos),
	    phos=res2$phos,
            SE2.Nnoshat=res2$SE2.Nnoshat,
            CV2.Nnoshat=res2$CV2.Nnoshat,
            SE2.Nhoshat=res2$SE2.Nhoshat,
            CV2.Nhoshat=res2$CV2.Nhoshat,
            SE2.phoshat=res2$SE2.phoshat,
            CV2.phoshat=res2$CV2.phoshat,
            BIAS2.phoshat=NA))
                
}

#uses Bootstrapping for multiple hatcheries
#uses cwt ratios to help esimate fractions of
#unmarked fish from hatchery i

#Use Bootstrapping for results
phos.mhatch.estimates1<-function(Nsims=10000,Nnos=200,Nhos=c(100,100),theta=0.25,
  lambda=c(0.75,.25),phi=c(.5,.9)){

#check dimension of inputs
k1<-length(Nhos);k2<-length(lambda);k3<-length(phi)
mytest<-abs(k1-k2)+abs(k2-k3)
if(mytest>0) stop("dimensions of Nhos, lambda, and phi must match")
nhatch<-length(Nhos)

#check inputs
if(sum(Nhos<0))stop("An Nhos estimate is negative")
if(Nnos<0)stop("Nnos estimate is negative")

#check lambdas (if they are all the same, the analysis simplifies)
mytest<-FALSE
if(nhatch==1){mytest==TRUE}
if(nhatch>1){mytest<-var(lambda)<1.e-10}
if(mytest){
#phis don’t matter at all – it’s as if there were a single hatchery
 res<-phos.estimates1(Nsims,Nnos=Nnos,Nhos=sum(Nhos),theta=theta,lambda=mean(lambda))
 phos=sum(Nhos)/(sum(Nhos)+Nnos)
 myres<-list(Nsims=Nsims,
		Nnos=Nnos,
		Nhos=Nhos,
		theta=theta,
		lambda=lambda,
		phi=phi,  
                phos=phos,
                SE.Nnoshat=res$SE.Nnoshat,
                CV.Nnoshat=res$CV.Nnoshat,
                SE.Nhoshat=res$SE.Nhoshat,
                CV.Nhoshat=res$CV.Nhoshat,              
		SE.phoshat=res$SE.phoshat,
		CV.phoshat=res$CV.phoshat,
		BIAS.phoshat=res$BIAS.phoshat)

 return(myres)
}

#check phis (must all exceed zero)
if(sum(phi==0))stop("phis must all be greater than zero")
phitest<-FALSE
if(sum(phi==1)==nhatch)phitest<-TRUE

 phos<-sum(Nhos)/(sum(Nhos)+Nnos)
#generate synthetic data sets
 Ehatchsampled<-matrix(NA,nrow=Nsims,ncol=nhatch)
 for(jj in 1:nhatch){
  Ehatchsampled[,jj] <-rbinom(Nsims,size=round(Nhos[jj]),prob=theta)
 }
 Enatsampled <-rbinom(Nsims,size=round(Nnos),prob=theta)
 Em<-matrix(NA,nrow=Nsims,ncol=nhatch)
 Emcwt<-matrix(NA,nrow=Nsims,ncol=nhatch)

 for(ii in 1:Nsims){
  for(jj in 1:nhatch){
  Em[ii,jj]<-rbinom(1,size=Ehatchsampled[ii,jj],prob=lambda[jj])
  Emcwt[ii,jj]<-rbinom(1,size=Em[ii,jj],prob=phi[jj])
 }}

#total unmarked fish (summing over all hatcheries)
 Emtot<-apply(Em,c(1),sum)
 Eu<-apply(Ehatchsampled,c(1),sum)-Emtot+Enatsampled
 
 Nhoshat<-rep(NA,Nsims)
#Replications of estimates
if(!phitest){
 for(ii in 1:Nsims){
  Nhoshat[ii]<-get.nhoshat(x1=Emcwt[ii,],x2=sum(Em[ii,]-Emcwt[ii,]),theta,lambda,phi=phi)
}}else{ 
 for(ii in 1:Nsims){
  Nhoshat[ii]<- sum(Emcwt[ii,]/(theta*lambda))
}}
 
 Ntothat<-Eu*(1/theta)+Emtot*(1/theta)
 Nnoshat<-Ntothat-Nhoshat
 phoshat<-Nhoshat/Ntothat

#properties of phos estimator
SE.Nhoshat<-sqrt(var(Nhoshat,na.rm=T))
CV.Nhoshat<-SE.Nhoshat/sum(Nhos)
SE.Nnoshat<-sqrt(var(Nnoshat,na.rm=T))
CV.Nnoshat<-SE.Nnoshat/Nnos
SE.phoshat<-sqrt(var(phoshat,na.rm=T))
CV.phoshat<-SE.phoshat/phos
BIAS.phoshat<-(mean(phoshat,na.rm=T)-phos)/phos

myres<-list(Nsims=Nsims,
                   Nnos=Nnos,
                   Nhos=Nhos,
                   theta=theta,
                   lambda=lambda,
                   phi=phi,
                   phos=phos,
                   SE.Nnoshat=SE.Nnoshat,
                   CV.Nnoshat=CV.Nnoshat,
                   SE.Nhoshat=SE.Nhoshat,
                   CV.Nhoshat=CV.Nhoshat,
                   SE.phoshat=SE.phoshat,
                   CV.phoshat=CV.phoshat,
                   BIAS.phoshat=BIAS.phoshat)
 return(myres)
}

#Theoretical results
phos.mhatch.estimates2<-function(Nnos=200,Nhos=c(100,100),theta=0.25,
  lambda=c(0.75,.25),phi=c(.5,.9)){

#check dimension of inputs
k1<-length(Nhos);k2<-length(lambda);k3<-length(phi)
mytest<-abs(k1-k2)+abs(k2-k3)
if(mytest>0) stop("dimensions of Nhos, lambda, and phi must match")
nhatch<-length(Nhos)

#check inputs
if(sum(Nhos<0))stop("An Nhos estimate is negative")
if(Nnos<0)stop("Nnos estimate is negative")

#check lambdas (if they are all the same, the analysis simplifies)
if(nhatch==1){mytest==TRUE}
if(nhatch>1){mytest<-var(lambda)<1.e-10}
if(mytest){
#phis don’t matter at all – it’s as if there were a single hatchery
 res<-phos.estimates2(Nnos=Nnos,
                        Nhos=sum(Nhos),
			theta=theta,
			lambda=mean(lambda))
 phos=sum(Nhos)/(sum(Nhos)+Nnos)
 myres<-list(Nnos=Nnos,
             Nhos=Nhos,
		theta=theta,
		lambda=lambda,
		phi=phi,
                phos=phos,
                SE2.Nnoshat=res$SE2.Nnoshat,
                CV2.Nnoshat=res$CV2.Nnoshat,
                SE2.Nhoshat=res$SE2.Nhoshat,
                CV2.Nhoshat=res$CV2.Nhoshat,
                SE2.phoshat=res$SE2.phoshat,
		CV2.phoshat=res$CV2.phoshat)
 return(myres)
}#mytest

#check phis (must all exceed zero)
if(sum(phi==0))stop("phis must all be greater than zero")
phitest<-FALSE
if(sum(phi==1)==nhatch)phitest<-TRUE
 phos<-sum(Nhos)/(sum(Nhos)+Nnos)

#theoretical formula for variance of phoshat
Ntot<-sum(Nhos)+Nnos
phosi<-Nhos/Ntot
if(!phitest){
 sum1<-sum(phosi*(1-theta*lambda*phi)/(theta*lambda*phi))
 sum2<-sum(phosi*(1-phi)/phi)
 sum3<-sum(phosi*(1-phi)*theta*lambda/phi)
 phos.var<-(1/Ntot)*(sum1-sum2*sum2/sum3-phos*phos*(1-theta)/theta)
 sum1<-sum(Nhos*(1-theta*lambda*phi)/(theta*lambda*phi))
 sum2<-sum(Nhos*(1-phi)/phi)
 sum3<-sum(Nhos*(1-phi)*theta*lambda/phi)
 Nhos.var<-sum1-sum2*sum2/sum3
 Nnos.var<-Ntot*(1-theta)/theta+Nhos.var-2*(1-theta)*sum(Nhos)/theta
}else{
 sum1<-sum(phosi*(1-theta*lambda)/(theta*lambda))
 phos.var<-(1/Ntot)*(sum1-phos*phos*(1-theta)/theta)
 Nhos.var<-sum(Nhos*(1-theta*lambda)/(theta*lambda))
 Nnos.var<-Ntot*(1-theta)/theta+Nhos.var-2*(1-theta)*sum(Nhos)/theta
}
 SE2.phoshat<-sqrt(phos.var)
 CV2.phoshat<-SE2.phoshat/phos
 SE2.Nhoshat<-sqrt(Nhos.var)
 CV2.Nhoshat<-SE2.Nhoshat/sum(Nhos)
 SE2.Nnoshat<-sqrt(Nnos.var)
 CV2.Nnoshat<-SE2.Nnoshat/Nnos

myres<-list(Nnos=Nnos,
                   Nhos=Nhos,
                   theta=theta,
                   lambda=lambda,
                   phi=phi,
                   phos=phos,
                   SE2.Nnoshat=SE2.Nnoshat,
                   CV2.Nnoshat=CV2.Nnoshat,
                   SE2.Nhoshat=SE2.Nhoshat,
                   CV2.Nhoshat=CV2.Nhoshat,
                   SE2.phoshat=SE2.phoshat,
                   CV2.phoshat=CV2.phoshat)
 return(myres)
}





#special case where all lambdas are the same (Bootstrapping Results)
phos.estimates1<-function(Nsims=10000,Nnos=100,Nhos=100,theta=0.25,lambda=0.75)
{
 Ntot<-Nhos+Nnos
 phos<-Nhos/Ntot
 Ehatchsampled <-rbinom(Nsims,size=round(Nhos),prob=theta)
 Enatsampled <-rbinom(Nsims,size=round(Nnos),prob=theta)
 Em<-rep(NA,Nsims)
 for(ii in 1:Nsims){
  Em[ii]<-rbinom(1,size=Ehatchsampled[ii],prob=lambda)
 }
 Eu<-Ehatchsampled-Em+Enatsampled

 Nhoshat<-Em*(1/theta)*(1/lambda)
 Ntothat<-Eu*(1/theta)+Em*(1/theta)
 Nnoshat<-Ntothat-Nhoshat
 phoshat<-Nhoshat/Ntothat
 SE.Nhoshat<-sqrt(var(Nhoshat,na.rm=T))
 CV.Nhoshat<-SE.Nhoshat/Nhos
 SE.Nnoshat<-sqrt(var(Nnoshat,na.rm=T))
 CV.Nnoshat<-SE.Nnoshat/Nnos
 SE.phoshat<-sqrt(var(phoshat,na.rm=T))
 CV.phoshat<-SE.phoshat/phos
 BIAS.phoshat<-(mean(phoshat,na.rm=T)-phos)/phos

 myres<-list(Nsims=Nsims,
                   Nnos=Nnos,
                   Nhos=Nhos,
                   theta=theta,
                   lambda=lambda,
                   phos=phos,
                   SE.Nhoshat=SE.Nhoshat,
                   CV.Nhoshat=CV.Nhoshat,
                   SE.Nnoshat=SE.Nnoshat,
                   CV.Nnoshat=CV.Nnoshat,
                   SE.phoshat=SE.phoshat,
                   CV.phoshat=CV.phoshat,
                   BIAS.phoshat=BIAS.phoshat)
		   
 return(myres)
 }

#special case where all lambdas are the same (theoretical results)
phos.estimates2<-function(Nnos=100,Nhos=100,theta=0.25,lambda=0.75)
{
 Ntot<-Nhos+Nnos
 phos<-Nhos/Ntot
 var.Nhoshat<-Nhos*(1-lambda*theta)/(lambda*theta)
 var.Nnoshat<-Nnos*(1-theta)/theta+Nhos*(1-lambda)/(theta*lambda)
 var.phos<-(phos/Ntot)*((1-lambda*theta)/(lambda*theta)-phos*(1-theta)/theta)
 SE2.Nhoshat<-sqrt(var.Nhoshat)
 CV2.Nhoshat<-SE2.Nhoshat/Nhos
 SE2.Nnoshat<-sqrt(var.Nnoshat)
 CV2.Nnoshat<-SE2.Nnoshat/Nnos
 SE2.phoshat<-sqrt(var.phos)
 CV2.phoshat<-SE2.phoshat/phos

 myres<-list(Nnos=Nnos,
                   Nhos=Nhos,
                   theta=theta,
                   lambda=lambda,
                   phos=phos,
                   SE2.Nnoshat=SE2.Nnoshat,
                   CV2.Nnoshat=CV2.Nnoshat,
                   SE2.Nhoshat=SE2.Nhoshat,
                   CV2.Nhoshat=CV2.Nhoshat,
                   SE2.phoshat=SE2.phoshat,
                   CV2.phoshat=CV2.phoshat)
		   
 return(myres)
}


#In general the estimate depends on the true values
#of escapement, so use iteration until the estimate converges
#Use fixed point iteration to get the GLSE
get.nhoshat<-function(x1,x2,theta,lambda,phi){
  etol<-1.e-10
  nhatch<-length(x1)
  Nhos0<-x1/(theta*lambda*phi)
  if(sum(c(x1,x2))<1.e-10)return(0.0)
  if((sum(x1)<1.e-10)&(x2>0))return(NA)
  run1<-sum(x1*(1-phi)/phi)
#initial guess
  Nhos<- Nhos0
  mynorm1<-sqrt(sum(Nhos*Nhos))
  err<-2.*etol*(mynorm1+etol)
  iter<-0
  while(err>etol*(mynorm1+etol)){
   rise<-Nhos*(1-phi)/(phi*theta)
   run<-sum(lambda*Nhos*(1-phi)/phi)
   Nhos<-Nhos0+(rise/run)*(x2-run1)
   mynorm2<-sqrt(sum(Nhos*Nhos))
   err<-abs(mynorm2-mynorm1)
   mynorm1<-mynorm2
   iter<-iter+1
   if(iter>100)stop("too many iterations in get.nhoshat")
  }
#  print(iter)
  return(sum(Nhos))
}

#
get.nhoshat.all<-function(x1,x2,theta,lambda,phi){
  etol<-1.e-10
  nhatch<-length(x1)
  Nhos0<-x1/(theta*lambda*phi)
  if(sum(c(x1,x2))<1.e-10)return(0.0)
  if((sum(x1)<1.e-10)&(x2>0))return(NA)
  run1<-sum(x1*(1-phi)/phi)
#initial guess
  Nhos<- Nhos0
  mynorm1<-sqrt(sum(Nhos*Nhos))
  err<-2.*etol*(mynorm1+etol)
  iter<-0
  while(err>etol*(mynorm1+etol)){
   rise<-Nhos*(1-phi)/(phi*theta)
   run<-sum(lambda*Nhos*(1-phi)/phi)
   Nhos<-Nhos0+(rise/run)*(x2-run1)
   mynorm2<-sqrt(sum(Nhos*Nhos))
   err<-abs(mynorm2-mynorm1)
   mynorm1<-mynorm2
   iter<-iter+1
   if(iter>100)stop("too many iterations in get.nhoshat")
  }
#  print(iter)
  return(Nhos)
}
</pre>
</div>
</div>
<div class="hide" id="tab3">
<a name="info_top"></a>
  <div class="info_text">
	<p>Here are some basic tips for using this tool. Choose from the topics below.</p>
		<ul>
		<li><a href="#info_choosing" class="tablink">Choosing Input Parameter Values</a></li>
		<li><a href="#info_calc" class="tablink">Obtaining Results</a></li>
		<li><a href="#info_interpret" class="tablink">Interpreting Results</a></li>
		<li><a href="#info_export" class="tablink">Exporting Data</a></li>
		<li><a href="#info_charts" class="tablink">Working With Charts</a></li>
		</ul>	
		
		<br>
		<a name="info_choosing"/>
		<span class="info_header">Choosing Input Parameter Values</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>
		<table border="1" cellmargin="2" class="users_guide_table" cellpadding="5">
	<tr><td valign="top" align="left" width="200"><p><b>x1</b></p></td><td align="top" valign="left"><p>The number of visibly marked and CWT spawners in the sample. Enter a comma-separated set of nonnegative numbers, one for each hatchery.</p></td></tr>
	<tr><td valign="top" align="left"><p><b>x2</b></p></td><td align="top" valign="left"><p>The number of visibly marked and not CWT spawners in the sample. Enter a nonnegative number.</p></td></tr>
	<tr><td valign="top" align="left"><p><b>Eu</b></p></td><td align="top" valign="left"><p>The number of spawners in the sample that are not visibly marked. Enter a nonnegative number</p></td></tr>
	<tr><td valign="top" align="left"><p><b>theta</b></p></td><td align="top" valign="left"><p>The sampling rate. Enter a number bewteen 0 and 1.</p></td></tr>
	<tr><td valign="top" align="left"><p><b>lambda</b></p></td><td align="top" valign="left"><p>The visible marking fraction. Enter a comma-separated set of numbers between zero and one, one for each hatchery.</p></td></tr>
	<tr><td valign="top" align="left"><p><b>phi</b></p></td><td align="top" valign="left"><p>The Coded Wire Tagged (CWT) fractions. Enter a comma-separated set of numbers between 0 and 1.</p></td></tr>
	<tr><td valign="top" align="left"><p><b>Analytical vs. Bootstrap</b></p></td><td align="top" valign="left"><p><em>Analytical:</em> -- Choose this option when the total spawners is sufficiently large so that the asymptotic large-sample properties hold for the formulas for SE and CV for the proportion of hatchery-origin spawners (phos). To determine what total spawner values are sufficient to accurately estimate SE and CV for phos, compare the analytical results to the Monte Carlo results. The Monte Carlo results do not depend on large-sample properties.</p>
<p><em>Bootstrap</em> -- Choose this option when the total number of spawners is small and asymptotic large-sample properties assumed in the SE and CV for the proportion of hatchery-origin spawners (phos) do not hold. Increasing the number of bootstrap replications will increase the accuracy of the output SE and CV values. Experiment with the number of replications until the desired accuracy is achieved.</p></td></tr>
	<tr><td align="top" valign="left"><p><b>Nsims</b></p></td><td align="top" valign="left"><p>The number of bootstrap replications. Not applicable for the Analytical treatment.</p></td></tr>
		</table>
	
		<br>
		<a name="info_calc"/>
		<span class="info_header">Obtaining Results</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>
		<p>To calculate results for a given set of input parameters, click on the <b>Calculate</b> button in the lower left corner. A row will be added to the data table to the right. Listed are the input parameters and the output parameters (indicated with gray shading).
		</p><p>
		To clear the values from the table, click on the <b>Clear button</b>.
		</p>
	
		<br>
		<a name="info_interpret"/>
		<span class="info_header">Interpreting Results</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>	
		<p>Output parameters are those displayed on the right side of the results table (unshaded cells).</p>
		<table border="1" cellmargin="2" class="users_guide_table" cellpadding="5">
				<tr><td valign="top" align="left"><p><b>Nnos</b></p></td><td align="top" valign="left"><p>Estimate of natural origin spawning escapement. </p></td></tr>
				<tr><td valign="top" align="left"><p><b>Nhos</b></p></td><td align="top" valign="left"><p>Estimate of total hatchery origin spawning escapement.</p></td></tr>
				<tr><td valign="top" align="left"><p><b>phos</b></p></td><td align="top" valign="left"><p>The proportion of hatchery-origin escapement</p></td></tr>
				<tr><td valign="top" align="left"><p><b>Nnos_SE</b></p></td><td align="top" valign="left"><p>Standard Error (SE) for the estimate of escapement of natural origin.</p></td></tr>
				<tr><td valign="top" align="left"><p><b>Nnos_CV</b></p></td><td align="top" valign="left"><p>The coefficient of variation (CV) for the estimate of escapement of natural origin fish. This equals the standard error for the estimate divided by the true escapement estimate.</p></td></tr>
				<tr><td valign="top" align="left"><p><b>Nhos_SE</b></p></td><td align="top" valign="left"><p>Standard Error (SE) for the estimate of escapement of hatchery origin.</p></td></tr>
				<tr><td valign="top" align="left"><p><b>Nhos_CV</b></p></td><td align="top" valign="left"><p>The coefficient of variation (CV) for the estimate of escapement of hatchery origin fish. This equals the standard error for the estimate divided by the true escapement estimate.</p></td></tr>
				<tr><td valign="top" align="left"><p><b>BIAS_phos</b></p></td><td align="top" valign="left"><p>The relative bias of the estimate of the proportion of hatchery-origin escapement. Relative bias is obtained by dividing the difference between the estimate and its true value by the true value. Relative bias is calculated only when the Bootstrap option is selected.</p></td></tr>
		</table>
		
		<br>
		<a name="info_export"/>
		<span class="info_header">Exporting Data</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>		
		<p>To export data, click the Export button. The data currently in the results table will be downloaded to your computer in comma-separated value (CSV) format. Note that multi-valued input variables (e.g phosi) are placed in a single cell separated by a "|" character.</p>
		
		<br>
		<a name="info_charts"/>
		<span class="info_header">Working With Charts</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>	
		<p>A common use of the tool is to study the effect of changing one input on one or more outputs in the calculation. Exporting the data for further analysis or presentation (as above) is one option, but as it is useful to get immediate feedback, real-time charting is provided.</p>
		<p>Charts provide an instant graphical display of the results of calculations. After at least two calculations are performed, the results are automatically plotted on the chart as an x-y scatterplot.  The following terms are useful in understanding the use and functionality of the Charts:</p>
		<ul>
		<li><i>Data Series</i><br/>
		A data series consists of a set of (two or more) calculations performed wherein <u>one</u> input parameter is varied</li>
		<li><i>Chart</i><br/>
		<p>The chart displays one or more data series with one of two plot types, depending on the input parameter chosen as the x-axis. For single-valued parameters, an x-y scatterplot is displayed, with the points optionally connected with lines. The x-axis should be the one varied across the data series (different for each calculation). The y-axis can be any of the output values. There is some functionality for customizing the chart.
		For multi-valued input parameters (i.e. where there is an entry for each hatchery), the chart displays the calculation results in the order performed, left to right, with the output value indicated along the x-axis as a short horizontal marker. There is no assumed relation (e.g. linear, etc.) of the different output values, and the values cannot be connected with lines.</p> 
		<p>Since any combination of hatchery-specific values can be chosen for each calculation, there is no general way for the charting routine to logically order the values (create an x-y scatterplot). It is thus up to the user to choose a set of inputs which makes sense for display purposes.</p>
		</li>
		<li><i>Chart Gallery</i><br/>
		The Chart Gallery provides a way to save various charts generated as you work for immediate comparison as well as making it possible to save each chart as an image to your computer.</li>
		</ul>
		
		<p>The best way to understand the function and capabilities of Charts is to walk through a typical scenario: <br/>We are interested primarily in the effect on the calculation result of changing one of the input parameters, and secondarily in the effect of changing yet another. Although we are specifically interested in the behaviour of one output parameter, 
		<ol>
		<li>Set initial input values, and then select one to sequentially modify.</li>
		<li>In the Chart Settings, assign the x-axis variable to the one selected above. Set the y-axis variable to whichever is of primary interest (not critical, as it can be changed later).</li>
		<li>Click the "Calculate" button. The result is added to the output table.</li>
		<li>Modify the primary input parameter (i.e. increment or decrement by some amount). Click the "Calculate" button. The result is added to the output table, and an x-y scatterplot is drawn showing both the current and the previous data points (optionally connected by a line). The scale of the plot automatically adjusts based on all values plotted.</li>
		<li>Repeat the last step as necessary to fully characterize the response.</li>
		<li>Add a title for the chart, and a label for the current data series. Click on the text box for each, type in the label, and then click outside the box to enable the change.</li>
		<li>At this point, you may choose to save the chart to the Chart Gallery. Click the "Add" button at bottom. The Gallery is opened with the current (right now, the only) chart on top. This is identical in appearance to what was previously visible, but is also a regular web graphic. You may right-click on this image to copy to clipboard or save to your computer. Close the Gallery when finished.</li>
		<li>We are interested in seeing the same results plotted using a different output parameter. Select a different value for y-axis variable in the Chart Settings. The chart is instantly updated. Add this to the gallery by clicking the "Add" button, and the Gallery opens with both the current and the previous charts visible (scroll down to see the previous). Close the Gallery.</li>
		<li>Now let's redo the calculations but with a change to a second input. First <b>(important!)</b> click the "+" button in the Chart Settings. This closes out the first data series and adds a second. Any subsequent calculations are assigned to this new data series.</li>
		<li>Repeat steps 4-5 above using the same set of primary input parameters, but with the secondary parameter given a new value. Each new result gets added, and the chart is redrawn to display all data from all data sets. Each data set is assigned a different color, and a legend is drawn which identifies them by label. The position of the legend can be selected (or hidden) in the Chart Settings</li>
		<li>After this, you have the option of saving to the Chart Gallery, adding more data series, or starting over with new data series. To do the latter, click the "Clear" button. <b>Note:</b> this also clears the Chart Gallery, so save any charts to your computer (i.e. using right-click and "Save As") before clearing.</li>
		</ol>
	  </div>
	</div>
	<div class="hide" id="tab4">
		<div class="info_text">
		<strong>Methodology and mathematical derivation:</strong><br>Richard Hinrichsen, Ph.D.<br>Hinrichsen Environmental Consulting<br>
		<a href="mailto:rich@hinrichsenenvironmental.com">rich@hinrichsenenvironmental.com</a><br><br>
		Rishi Sharma, Ph.D.<br><br>
		
		<strong>Tool programming and web development:</strong><br>Brian Maschhoff, Ph.D.<br>Salmonetics<br>
		<a href="mailto:brianm@exelearn.com">brianm@exelearn.com</a><br><br>
		<strong>Acknowledgement:</strong> <br>We gratefully acknowledge the support of Bonneville Power Administration<br> in the development of this web tool.
		</div>
	</div>	
  </div>
</div>


<!-- Site Meter -->
<a href="http://s33.sitemeter.com/stats.asp?site=s33onefishtwofish" target="_new">
<img src="http://s33.sitemeter.com/meter.asp?site=s33onefishtwofish" alt="Site Meter" border="0"/></a>
<!-- Copyright (c)2009 Site Meter -->
</body>
</html>


