<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<head>
<link rel="icon" type="image/gif" href="http://onefishtwofish.net/images/salmon_ico.gif">
<link rel="stylesheet" type="text/css" href="http://www.onefishtwofish.net/styles/fish.css" />
<link rel="stylesheet" type="text/css" href="../styles/tab_style.css" />
<title>HatchPBT -- OneFishTwoFish</title>

<style>
div.info {
	width: 1061px;
	height: 900px;
	overflow:auto;	
	}
div.tabs {
	width: 1061px;
	}
div.info_text {
	overflow:auto;
	margin-left: 10px;
	margin-right: 10px;
	padding-left: 0px;
	padding-top: 0px;
	}
div.tool{
	overflow:hidden;
	width: 980px;
}

div.code{
	font-family: Arial, Sans-Serif;
	font-size: 12px;
}	

.users_guide_table {
font-family: arial, helvetica;
font-size: 10pt;
cursor: default;
margin: 0;
background: white;
border-spacing: 0;
padding: 5px;
}

.info_header {
	margin-top: 20px;
	font-family: arial, helvetica;
	font-size: 11pt;
	font-weight: bold;
}

p {
	font-family: arial, helvetica;
	font-size: 11pt;
}

			
</style>

<script src="../script/tabjs.js"></script>
<script src="../script/spry/SpryEffects.js" type="text/javascript"></script>
<script type="text/javascript">
  			
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-18774702-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  
</script>
</head>

<!-- without body tag IE may have unprodictable behaviours -->
<body bgcolor="#faff05">
<a href="http://www.onefishtwofish.net/" alt="OFTF Home"><img src="../images/logo_tagline2.jpg" border="0"></a>
<p><b>HatchPBT : A statistical tool to conduct an a priori analysis of the precision and accuracy of the maximum likelihood estimator of the proportion of hatchery-origin spawners using parentage-based tagging</b></p>
<script>
var nojs=0;
</script>
<noscript>
<div>
<p style="{color: #ff0000;}"><b>To view the tool documentation, javascript needs to be enabled on your computer.</b></p>
<p>In Internet Explorer, select <i>Tools =&gt; Internet Options =&gt; Security =&gt; Custom</i>, scroll down to Scripting/Active Scripting, and set it to <b>Enable</b>. 
<p>In Firefox, select <i>Tools =&gt; Options =&gt; Content</i>, and ensure that <b>Enable Javascript</b> is checked.</p>
</div></noscript>
<div class="tabs">
	<table cellspacing="0" cellpadding="0">
		<tr bgcolor="#ffffff" id="one" style="{display: block;}">
		<td class="tab"><img src="../images/left1.gif"></td><td nowrap background="../images/back1.gif">&nbsp;Tool&nbsp;</TD><td><img src="../images/mid10.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab2'); setTabs('two');" class="tablink">&nbsp;Background&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab3'); setTabs('three');" class="tablink">&nbsp;User's Guide&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab4'); setTabs('four');" class="tablink">&nbsp;Credits&nbsp;</a></TD><td><img src="../images/right0.gif"></td>	
		</tr>
		<tr bgcolor="#ffffff" id="two" class="hide">
		<td class="tab"><img src="../images/left0.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab1'); setTabs('one');" class="tablink">&nbsp;Tool&nbsp;</a></TD><td><img src="../images/mid01.gif"></td><td nowrap background="../images/back1.gif">&nbsp;Background&nbsp;</TD><td><img src="../images/mid10.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab3'); setTabs('three');" class="tablink">&nbsp;User's Guide&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab4'); setTabs('four');" class="tablink">&nbsp;Credits&nbsp;</a></TD><td><img src="../images/right0.gif"></td>	
		</tr>
		<tr bgcolor="#ffffff" id="three" class="hide">
		<td class="tab"><img src="../images/left0.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab1'); setTabs('one');" class="tablink">&nbsp;Tool&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab2'); setTabs('two');" class="tablink">&nbsp;Background&nbsp;</a></TD><td><img src="../images/mid01.gif"></td><td nowrap background="../images/back1.gif">&nbsp;User's Guide&nbsp;</TD><td><img src="../images/mid10.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab4'); setTabs('four');" class="tablink">&nbsp;Credits&nbsp;</a></TD><td><img src="../images/right0.gif"></td>
		</tr>	
		<tr bgcolor="#ffffff" id="four" class="hide">
		<td class="tab"><img src="../images/left0.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab1'); setTabs('one');" class="tablink">&nbsp;Tool&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif"><a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab2'); setTabs('two');" class="tablink">&nbsp;Background&nbsp;</a></TD><td><img src="../images/mid00.gif"></td><td nowrap background="../images/back0.gif">&nbsp;<a href="javascript:void(0);" onclick="Hide(CURRENT);
	Show('tab3'); setTabs('three');" class="tablink">User's Guide&nbsp;</a></TD><td><img src="../images/mid01.gif"></td><td nowrap background="../images/back1.gif">&nbsp;Credits&nbsp;</TD><td><img src="../images/right1.gif"></td>
		</tr>						
	</table>
</div>
<div class="info">
	<div style="display: inline;" id="tab1">
		<iframe src="http://ec2-54-176-167-218.us-west-1.compute.amazonaws.com/html/pbthatch4.5.html" width="1060" height="880" frameborder="0" scrolling="no">
		You really need to enable iframes to use this tool...
		</iframe>
	</div>
<div class="hide" id="tab2">
	<div class="info_text">
		<p>HatchPBT is used to compare study designs aimed at estimating the proportion of hatchery-origin spawners (p) in a program that uses visible marks (VM, e.g. adipose fin clip) and parentage-based tags (PBT) to identify hatchery-origin spawners on a spawning ground. The inputs include true values of the proportion (fraction) of hatchery-origin fish from each of one or more hatcheries, VM and PBT fractions for each of the source hatcheries, the total sample size (spawners recovered), and the numbers of marked and unmarked spawners tested for a PBT. The outputs are estimates of the precision and accuracy of the maximum likelihood estimate of p, which can be used to guide the selection of a study design.</p>
		<p><em>Disclaimer: This use of this tool is free and comes with absolutely no warranty.</em></p>
		<p>The mathematical derivations are given in this paper (pdf):</p>
		<p><a href="http://www.onefishtwofish.net/pbthatch/documents/PBT-webtool-mhatch-7-10-2013.pdf" target="_new">HATCHPBT :
A statistical tool to conduct an a priori analysis of the precision and accuracy of the maximum likelihood estimator of the proportion of hatchery-origin spawners using parentage-based tagging</a></p>
		<p>and can be reproduced with the following <strong>R</strong> code:</p>

<div class="code">
#Program to calculate statistical properties of phos estimates using maximum likelihood theory <br>
#and Monte Carlo Simulation. This code allows inputs from several hatcheries with <br>
#potentially different visual marking (VM) fractions and different parentage-based tagging (PBT) fractions. <br>
#FILE: pbt-web-7-10-2013.s<br>
#AUTHOR: Richard A. Hinrichsen, 10 July 2013<br>
<br>
#Variables and parameters used in the analysis<br>
#inputs<br>
#phosi = true proportions of hatchery origin spawners (hatchery-specific)<br>
#Nsamp = total number of spawners sampled on spawning grounds<br>
#n = total number of spawners tested for PBT<br>
#n1 = number of visually marked spawners tested for PBT (when OPT=FALSE)<br>
#lambda = marking fraction (hatchery-specific)<br>
#ppbt = fraction of fish that are PBT (hatchery-specific)<br>
#OPT = FALSE when n1 is user input, TRUE when program to select an optimal value of n1<br>
#MONTE = FALSE for theoretical results, TRUE for Monte Carlo results<br>
#NSIM = number of Monte Carlo simulations (needed if MONTE=TRUE)<br>
#<br>
#<br>
#Select intermediate variables<br>
#nhatch = number of hatcheries supplying spawners to spawning grounds<br>
#I = Fisher Information Matrix<br>
#x1 = number of visually marked spawners in sample of size Nsamp<br>
#x2 = number of unmarked spawners in sample of size Nsamp<br>
#n2 = number of unmarked spawners tested for PBT<br>
#y = number of visually marked spawners tested that were PBT (hatchery-specific)<br>
#z = number of unmarked spawners tested that were PBT (hatchery-specific)<br>
#Ey = expected value of y<br>
#Ez = expected value of z<br>
<br>
#Results<br>
#phos = true proportion of hatchery-origin spawners<br>
#Ex1 = expected number of visually marked spawners (summing over hatcheries)<br>
#Ex2 = expected number of not visually marked spawners (summing over hatcheries)<br>
#SE_MIN.phos = standard error (SE) when all sampled fish are tested for PBT<br>
#CV_MIN.phos = Coefficient of variation when ALL sampled fish are tested for PBT<br>
#SE.phos = standard error (SE) <br>
#CV.phos = Coefficient of variation <br>
#BIAS.phos = relative bias estimate (NA if MONTE=FALSE)<br>
#n1 = optimal number of visually marked spawners tested for PBT (when OPT=TRUE)<br>
<br>
#top level function<br>
phos.pbt.main&lt-function(phosi=.1*c(1/20,1/20,9/20,9/20),<br>
                        Nsamp=1000,n=200,n1=50,<br>
                        lambda=c(1,.95,.5,.5),<br>
                        ppbt=c(.95,.95,.95,.95),<br>
                        OPT=FALSE,<br>
                        MONTE=FALSE,NSIM=1000){<br>
        check.inputs(phosi,Nsamp,n,n1,lambda,ppbt,OPT,MONTE,NSIM)<br>
        if(!OPT){<br>
        if(!MONTE){res&lt-phos.pbt.estimates(phosi=phosi,Nsamp=Nsamp,n=n,n1=n1,lambda=lambda,ppbt=ppbt,suppress=FALSE)}<br>
        if(MONTE){res&lt-phos.pbt.estimates2(NSIM=NSIM,phosi=phosi,Nsamp=Nsamp,n=n,n1=n1,lambda=lambda,ppbt=ppbt)}}<br>
        if(OPT){res&lt-optimize(phosi=phosi,Nsamp=Nsamp,n=n,lambda=lambda,ppbt=ppbt)}<br>
        final.res&lt-list(OPT=OPT,<br>
                   MONTE=res$MONTE,<br>
                   NSIM=res$NSIM,<br>
                   phosi=res$phosi,<br>
                   Nsamp=res$Nsamp,<br>
                   n=res$n,<br>
                   n1=res$n1,<br>
                   lambda=res$lambda,<br>
                   ppbt=res$ppbt,<br>
                   phos=res$phos,<br>
                   Ex1=res$Ex1,<br>
                   Ex2=res$Ex2,<br>
                   SE_MIN.phos=res$SE_MIN.phos,<br>
                   CV_MIN.phos=res$CV_MIN.phos,<br>
                   SE.phos=res$SE.phos,<br>
                   CV.phos=res$CV.phos,<br>
                   BIAS.phos=res$BIAS.phos)<br>
        return(final.res)<br>
}<br>
<br>
#check of feasibility of optimization<br>
#avoid unusual case where hatcheries with zero expected tags recoveries<br>
#and these hatcheries do not all use the same visible marking fraction<br>
is.feas&lt-function(phosi,Nsamp,n,n1,lambda,ppbt){<br>
 n2&lt-n-n1<br>
 onelambda2&lt-TRUE<br>
 iii&lt-n1*lambda*ppbt+n2*(1-lambda)*ppbt==0<br>
 onelambda2&lt-sum(mean(lambda[iii])==lambda[iii])==sum(iii)<br>
 onelambda2&lt-onelambda2&(mean(lambda[iii])>0)<br>
 if((!onelambda2)&sum(iii))return(FALSE)<br>
 return(TRUE)<br>
}<br>
<br>
#Find the value of n1 that minimizes CV<br>
optimize&lt-function(phosi,Nsamp,n,lambda,ppbt){<br>
 #loop over all feasible values of n1<br>
 #note that n1 might be a non-integer because the constraints are not necessarily integers<br>
 Ex1&lt-Nsamp*sum(lambda*phosi)<br>
 min.n1&lt-max(Ex1-(Nsamp-n),0)<br>
 max.n1&lt-min(Ex1,n)<br>
 min.int&lt-ceiling(min.n1)<br>
 max.int&lt-floor(max.n1)<br>
 if(min.int>=max.int){n1s&lt-min.n1}<br>
 if(min.int&ltmax.int){n1s&lt-c(min.n1,min.int:max.int,max.n1)}<br>
 n1s&lt-unique(n1s)<br>
 nfeas&lt-length(n1s)<br>
 cv&lt-1.e10<br>
 icount&lt-0<br>
 for(ii in 1:nfeas){<br>
  if(is.feas(phosi=phosi,Nsamp=Nsamp,n=n,n1=n1s[ii],lambda=lambda,ppbt=ppbt)){<br>
  icount&lt-icount+1<br>
  res.new&lt-phos.pbt.estimates(phosi=phosi,Nsamp=Nsamp,n=n,n1=n1s[ii],lambda=lambda,ppbt=ppbt,suppress=TRUE)<br>
  if(res.new$CV.phos&ltcv){res&lt-res.new;n1&lt-res.new$n1;cv&lt-res.new$CV.phos}}<br>
 }<br>
 if(icount==0)stop(&quotError in optimize: no feasible values are available for n1&quot)<br>
 return(res)<br>
}<br>
<br>
#make sure the inputs make sense<br>
check.inputs&lt-function(phosi,Nsamp,n,n1,lambda,ppbt,OPT,MONTE,NSIM){<br>
 if(!is.logical(OPT))stop(&quotOPT must be TRUE or FALSE&quot)<br>
 if(!is.logical(MONTE))stop(&quotMONTE must be TRUE or FALSE&quot)<br>
 if(OPT){<br>
 if(MONTE){stop(&quotFor the optimization option, the program cannot be run in Monte Carlo mode&quot)}}<br>
 if(MONTE){<br>
 if(floor(NSIM)!=NSIM){stop(&quotNSIM must be a positive integer&quot)}<br>
 if(NSIM&lt=0){stop(&quotNSIM must be a positive integer&quot)}}<br>
 if(floor(Nsamp)!=Nsamp){stop(&quotNsamp must be a positive integer&quot)}<br>
 if(Nsamp&lt=0){stop(&quotNsamp must be a positive integer&quot)}<br>
#check dimension of inputs<br>
 k1&lt-length(phosi);k2&lt-length(lambda);k3&lt-length(ppbt)<br>
 mytest&lt-abs(k1-k2)+abs(k2-k3)<br>
 if(mytest>0) stop(&quotdimensions of phosi, lambda, and ppbt must match&quot)<br>
#check constraints on ppbt, phosi, and lambda<br>
 if(sum(ppbt&lt0))stop(&quotppbts must all be greater than or equal to zero&quot)<br>
#check that each ppbt is less than or equal to one<br>
 if(sum(ppbt>1))stop(&quotppbts must all be less than or equal to 1.0&quot)<br>
#check that all lambdas are between zero and 1.0<br>
 if(sum(lambda&lt0))stop(&quotlambdas must all be greater than or equal to zero&quot)<br>
 if(sum(lambda>1))stop(&quotlambdas must all be less than or equal to one&quot)<br>
#check that all phosi are between zero and 1.0<br>
 if(sum(phosi&lt=0))stop(&quotphosis must all be greater than zero&quot)<br>
 if(sum(phosi>1))stop(&quotphosis must all be less than or equal to one&quot)<br>
#check that the subsample size is less than sample size<br>
 if(n>Nsamp)stop(paste(&quotn must be less than or equal to Nsamp=&quot,Nsamp))<br>
#get expected values of observations<br>
 Ex1&lt-Nsamp*sum(lambda*phosi)<br>
 Ex2&lt-Nsamp-Ex1<br>
#check subsample. Note in the case of OPT==TRUE, n1 might be changed<br>
 if(!OPT){<br>
 if(n1&lt0)stop(&quotn1 must be nonnegative&quot)<br>
 if(n&ltn1)stop(&quotn must be greater than or equal to n1&quot)<br>
 if(n1>Ex1)stop(paste(&quotn1 must not exceed the expected number of VM spawners in sample=&quot,Ex1))<br>
 if(n1&lt(n-Ex2))stop(paste(&quotn1 must be >= n minus the expected number of ~VM spawners in sample=&quot,n-Ex2))}<br>
 n2&lt-n-n1<br>
 if(!OPT){<br>
 iii&lt-n1*lambda*ppbt+n2*(1-lambda)*ppbt==0}<br>
#note in the case of OPT that n1 might be changed to allow estimation<br>
if(OPT){<br>
 iii&lt-(lambda*ppbt+(1-lambda)*ppbt==0)|(n==0)}<br>
 onelambda2&lt-sum(mean(lambda[iii])==lambda[iii])==sum(iii)<br>
 onelambda2&lt-onelambda2&(mean(lambda[iii])>0)<br>
 if((!onelambda2)&sum(iii)){<br>
  stop(&quotExpected tag recoveries must not be zero when marking fractions differ or are zero&quot)}<br>
<br>
 return(NULL)<br>
}<br>
<br>
#Theoretical results using maximum likelihood theory<br>
phos.pbt.estimates&lt-function(phosi=.1*c(1/20,1/20,9/20,9/20),<br>
Nsamp=1000,n=200,n1=50,lambda=c(1,.95,.5,.5),ppbt=c(.95,.95,.95,.95),<br>
suppress){<br>
 n2&lt-n-n1<br>
 nhatch&lt-length(lambda)<br>
#get expected values of observations<br>
 Ex1&lt-Nsamp*sum(lambda*phosi)<br>
 Ex2&lt-Nsamp-Ex1<br>
 Ey&lt-n1*lambda*ppbt*phosi/sum(lambda*phosi)<br>
 Ez&lt-n2*(1-lambda)*ppbt*phosi/(1-sum(lambda*phosi))<br>
 Ey2&lt-Ex1*lambda*ppbt*phosi/sum(lambda*phosi)<br>
 Ez2&lt-Ex2*(1-lambda)*ppbt*phosi/(1-sum(lambda*phosi))<br>
 if(sum(lambda)==0){<br>
  Ey&lt-0<br>
  Ez&lt-n2*ppbt*phosi<br>
  Ey2&lt-0<br>
  Ez2&lt-Ex2*ppbt*phosi<br>
 }<br>
 phos&lt-sum(phosi)<br>
#get estimates using pbte routines<br>
 res&lt-phos.pbte.estimates(x1=Ex1,x2=Ex2,n1=n1,n2=n2,y=Ey,z=Ez,lambda,ppbt,suppress=suppress)<br>
 res2&lt-phos.pbte.estimates(x1=Ex1,x2=Ex2,n1=Ex1,n2=Ex2,y=Ey2,z=Ez2,lambda,ppbt,suppress=suppress)<br>
 myres&lt-list(MONTE=FALSE,<br>
                   NSIM=NA,<br>
                   phosi=phosi,<br>
                   Nsamp=Nsamp,<br>
                   n=n,<br>
                   n1=n1,<br>
                   lambda=lambda,<br>
                   ppbt=ppbt,<br>
                   phos=phos,<br>
                   Ex1=Ex1,<br>
                   Ex2=Ex2,<br>
                   SE_MIN.phos=res2$SE.phos,<br>
                   CV_MIN.phos=res2$CV.phos,<br>
                   SE.phos=res$SE.phos,<br>
                   CV.phos=res$CV.phos,<br>
                   BIAS.phos=NA)<br>
 return(myres)<br>
}<br>
<br>
#Monte Carlo estimates of standard error and relative bias<br>
phos.pbt.estimates2&lt-function(NSIM=1000,phosi=.1*c(1/20,1/20,9/20,9/20),<br>
 Nsamp=1000,n=n,n1=50,lambda=c(1,.95,.5,.5),ppbt=c(.95,.95,.95,.95)){<br>
 n2&lt-n-n1<br>
 nhatch&lt-length(phosi)<br>
#get expected values of observations<br>
 Ex1&lt-Nsamp*sum(lambda*phosi)<br>
 Ex2&lt-Nsamp-Ex1<br>
 Ey&lt-n1*lambda*ppbt*phosi/sum(lambda*phosi)<br>
 Ez&lt-n2*(1-lambda)*ppbt*phosi/(1-sum(lambda*phosi))<br>
 Ey2&lt-Ex1*lambda*ppbt*phosi/sum(lambda*phosi)<br>
 Ez2&lt-Ex2*(1-lambda)*ppbt*phosi/(1-sum(lambda*phosi))<br>
 if(sum(lambda)==0){<br>
  Ey&lt-0<br>
  Ez&lt-n2*ppbt*phosi<br>
  Ey2&lt-0<br>
  Ez2&lt-Ex2*ppbt*phosi<br>
 }<br>
 phos&lt-sum(phosi)<br>
 res&lt-phos.pbte.estimates2(NBOOT=NSIM,x1=Ex1,x2=Ex2,n1=n1,n2=n2,y=Ey,z=Ez,lambda,ppbt)<br>
 res2&lt-phos.pbte.estimates2(NBOOT=NSIM,x1=Ex1,x2=Ex2,n1=Ex1,n2=Ex2,y=Ey2,z=Ez2,lambda,ppbt)<br>
<br>
 myres&lt-list(MONTE=TRUE,<br>
                   NSIM=NSIM,<br>
                   phosi=phosi,<br>
                   Nsamp=Nsamp,<br>
                   n=n,<br>
                   n1=n1,<br>
                   lambda=lambda,<br>
                   ppbt=ppbt,<br>
                   phos=phos,<br>
                   Ex1=Ex1,<br>
                   Ex2=Ex2,<br>
                   SE_MIN.phos=res2$SE.phos,<br>
                   CV_MIN.phos=res2$CV.phos,<br>
                   SE.phos=res$SE.phos,<br>
                   CV.phos=res$CV.phos,<br>
                   BIAS.phos=res$BIAS.phos)<br>
 return(myres)<br>
}<br>
<br>
#Maximum Likelihood Theory results<br>
phos.pbte.estimates&lt-function(x1,x2,n1,n2,y,z,lambda,ppbt,suppress){<br>
 nhatch&lt-length(lambda)<br>
 Nsamp&lt-x1+x2<br>
<br>
#An important case for combining cells occurs when the expected w=x+y=0<br>
#in this case, constant lambdas over these cells saves the estimation.<br>
#note that this also takes care of the case with a single lambda for all hatcheries<br>
iii&lt-n1*lambda*ppbt+n2*(1-lambda)*ppbt==0<br>
onelambda2&lt-sum(lambda[iii]==mean(lambda[iii]))==sum(iii)<br>
if((sum(iii)>1)&onelambda2){<br>
 if(!suppress)warning(&quotcollapsing cells with expected tag recoveries of zero into single cell since lambda is constant&quot)<br>
 lambda1.new&lt-mean(lambda[iii])<br>
 ppbt1.new&lt-0.0<br>
 lambda.new&lt-c(lambda1.new,lambda[!iii])<br>
 ppbt.new&lt-c(ppbt1.new,ppbt[!iii])<br>
 y.new&lt-c(0,y[!iii])<br>
 z.new&lt-c(0,z[!iii])<br>
 nhatch.new&lt-length(lambda.new)<br>
 res&lt-phos.pbte.estimates(x1=x1,x2=x2,n1=n1,n2=n2,y=y.new,z=z.new,lambda=lambda.new,ppbt=ppbt.new,suppress=suppress)<br>
 phosi&lt-rep(NA,nhatch)<br>
 SE.phosi&lt-rep(NA,nhatch)<br>
 phosi[!iii]&lt-res$phosi[2:nhatch.new]<br>
 SE.phosi[!iii]&lt-res$SE.phosi[2:nhatch.new]<br>
<br>
 myres&lt-list(BOOT=FALSE,<br>
                   NBOOT=NA,<br>
                   Nsamp=Nsamp,<br>
                   x1=x1,<br>
                   x2=x2,<br>
                   n=n1+n2,<br>
                   n1=n1,<br>
                   n2=n2,<br>
                   y=y,<br>
                   z=z,<br>
                   lambda=lambda,<br>
                   ppbt=ppbt,<br>
                   phosi=phosi,<br>
                   SE.phosi=SE.phosi,<br>
                   phos=res$phos,<br>
                   SE.phos=res$SE.phos,<br>
                   CV.phos=res$CV.phos,<br>
                   BIAS.phos=NA)<br>
 return(myres)<br>
}<br>
<br>
<br>
#get initial estimate of phosi<br>
phosi.init&lt-init(x1,x2,n1,n2,y,z,lambda,ppbt,suppress=suppress)<br>
<br>
myres&lt-get.estimates2(phosi.init,x1,x2,n1,n2,y,z,lambda,ppbt,suppress=suppress)<br>
phos&lt-myres$phos<br>
phos.var&lt-myres$phos.var<br>
phosi&lt-myres$phosi<br>
SE.phosi&lt-sqrt(myres$phosi.var)<br>
<br>
<br>
SE.phos&lt-sqrt(phos.var)<br>
CV.phos&lt-SE.phos/phos<br>
SE.phos&lt-as.numeric(SE.phos)<br>
CV.phos&lt-as.numeric(CV.phos)<br>
<br>
myres&lt-list(BOOT=FALSE,<br>
                   NBOOT=NA,<br>
                   Nsamp=Nsamp,<br>
                   x1=x1,<br>
                   x2=x2,<br>
                   n=n1+n2,<br>
                   n1=n1,<br>
                   n2=n2,<br>
                   y=y,<br>
                   z=z,<br>
                   lambda=lambda,<br>
                   ppbt=ppbt,<br>
                   phosi=phosi,<br>
                   SE.phosi=SE.phosi,<br>
                   phos=phos,<br>
                   SE.phos=SE.phos,<br>
                   CV.phos=CV.phos,<br>
                   BIAS.phos=NA)<br>
 return(myres)<br>
}<br>
<br>
#Fisher Information Matrix (general case)<br>
getI&lt-function(Nsamp,n1,n2,lambda,ppbt,phosi){<br>
 Ex1&lt-Nsamp*sum(lambda*phosi)<br>
 Ex2&lt-Nsamp-Ex1<br>
 theta1&lt-n1/Ex1<br>
 theta2&lt-n2/Ex2<br>
<br>
 v&lt-lambda<br>
 I&lt- v%*%t(v)*Nsamp*(1-theta1)/sum(v*phosi)<br>
 I&lt-I +v%*%t(v)*Nsamp*(1-theta2)/(1-sum(v*phosi))<br>
<br>
 v&lt-(1-ppbt)*lambda<br>
 I&lt-I+v%*%t(v)*Nsamp*theta1/sum(v*phosi)<br>
<br>
 v&lt-lambda*(1-ppbt)+ppbt<br>
 I&lt-I+v%*%t(v)*Nsamp*theta2/(1-sum(v*phosi))<br>
<br>
#fix diagonal<br>
 mydiag&lt-diag(I)+Nsamp*ppbt*(theta1*lambda+theta2*(1-lambda))/phosi<br>
 diag(I)&lt-mydiag<br>
 return(I)<br>
}<br>
<br>
#Fisher Information matrix used when all VM releases PBT<br>
getI2&lt-function(Nsamp,n1,n2,lambda,ppbt,phosi){<br>
 Ex1&lt-Nsamp*sum(lambda*phosi)<br>
 Ex2&lt-Nsamp-Ex1<br>
 theta1&lt-n1/Ex1<br>
 theta2&lt-n2/Ex2<br>
<br>
 v&lt-lambda<br>
 I&lt- v%*%t(v)*Nsamp*(1-theta1)/sum(v*phosi)<br>
 I&lt-I +v%*%t(v)*Nsamp*(1-theta2)/(1-sum(v*phosi))<br>
<br>
 v&lt-ppbt<br>
 I&lt-I+v%*%t(v)*Nsamp*theta2/(1-sum(v*phosi))<br>
<br>
#fix diagonal<br>
 mydiag&lt-diag(I)+Nsamp*ppbt*(theta1*lambda+theta2*(1-lambda))/phosi<br>
 diag(I)&lt-mydiag<br>
 return(I)<br>
}<br>
<br>
#Fisher Information matrix (used when all lambdas are zero)<br>
getI3&lt-function(Nsamp,n1,n2,lambda,ppbt,phosi){<br>
 Ex2&lt-Nsamp<br>
 theta2&lt-n2/Ex2<br>
 v&lt-ppbt<br>
 I&lt-v%*%t(v)*Nsamp*theta2/(1-sum(v*phosi))<br>
#fix diagonal<br>
 mydiag&lt-diag(I)+Nsamp*ppbt*theta2/phosi<br>
 diag(I)&lt-mydiag<br>
 return(I)<br>
}<br>
<br>
#Bootstrap estimates of standard error and bias<br>
#consider cases where some of the phosi are missing<br>
phos.pbte.estimates2&lt-function(NBOOT,x1,x2,n1,n2,y,z,lambda,ppbt){<br>
 nhatch&lt-length(lambda)<br>
 Nsamp&lt-x1+x2<br>
#get MLE using theoretical results<br>
 res&lt-phos.pbte.estimates(x1,x2,n1,n2,y,z,lambda,ppbt,suppress=FALSE)<br>
 phosi&lt-res$phosi<br>
 phosi.orig&lt-res$phosi<br>
 phos&lt-res$phos<br>
 phos.sim&lt-rep(NA,NBOOT)<br>
 phosi.sim&lt-matrix(NA,nrow=NBOOT,ncol=nhatch)<br>
 if(!is.na(phos)){<br>
 for(ii in 1:NBOOT){<br>
  iii&lt-is.na(phosi)<br>
  phosi[iii]&lt-rep(phos-sum(phosi,na.rm=T),sum(iii))/sum(iii)<br>
  mysim&lt-pbtsim1(phosi,Nsamp,n1,n2,res$lambda,res$ppbt)<br>
  my.n1&lt-n1<br>
  my.n2&lt-n2<br>
  if(mysim$x1&ltn1)my.n1&lt-mysim$x1<br>
  if(mysim$x2&ltn2)my.n2&lt-mysim$x2<br>
  res&lt-phos.pbte.estimates(x1=mysim$x1,x2=mysim$x2,n1=my.n1,n2=my.n2,<br>
                  y=mysim$y,z=mysim$z,lambda=lambda,ppbt=ppbt,suppress=TRUE)<br>
  phos.sim[ii]&lt-res$phos<br>
  phosi.sim[ii,]&lt-res$phosi<br>
 <br>
 }}<br>
<br>
 SE.phosi&lt-apply(phosi.sim,c(2),var,na.rm=T)<br>
 SE.phosi&lt-sqrt(SE.phosi)<br>
 SE.phos&lt-sqrt(var(phos.sim,na.rm=T))<br>
 CV.phos&lt-SE.phos/phos<br>
 mymean&lt-mean(phos.sim,na.rm=T)<br>
 BIAS.phos&lt-(mymean-phos)/phos<br>
<br>
 myres&lt-list(BOOT=TRUE,<br>
                   NBOOT=NBOOT,<br>
                   Nsamp=Nsamp,<br>
                   x1=x1,<br>
                   x2=x2,<br>
                   n=n1+n2,<br>
                   n1=n1,<br>
                   n2=n2,<br>
                   y=y,<br>
                   z=z,<br>
                   lambda=lambda,<br>
                   ppbt=ppbt,<br>
                   phosi=phosi.orig,<br>
                   SE.phosi=SE.phosi,<br>
                   phos=phos,<br>
                   SE.phos=SE.phos,<br>
                   CV.phos=CV.phos,<br>
                   BIAS.phos=BIAS.phos)<br>
 return(myres)<br>
}<br>
<br>
#simulate data when phosi available<br>
pbtsim1&lt-function(phosi,Nsamp,n1,n2,lambda,ppbt){<br>
 m&lt-length(phosi)<br>
#first get binomial sample of fish marked and unmarked<br>
 P&lt-sum(phosi*lambda)<br>
 x1&lt-rbinom(n=1,size=Nsamp,prob=P)<br>
 x2&lt-Nsamp-x1<br>
#next use multinomial distribution to simulate<br>
#how many fish are pbt and how many are not pbt<br>
 py&lt-ppbt*phosi*lambda/P<br>
 pz&lt-ppbt*phosi*(1-lambda)/(1-P)<br>
 if(P>0){y&lt-rmultinom(n=1,size=min(n1,x1),prob=c(py,1-sum(py)))}<br>
 if(P==0){y&lt-matrix(0,ncol=1,nrow=length(phosi))}<br>
 if(P&lt1){z&lt-rmultinom(n=1,size=min(n2,x2),prob=c(pz,1-sum(pz)))}<br>
 if(P==1){z&lt-matrix(0,ncol=1,nrow=length(phosi))}<br>
<br>
 return(list(Nsamp=Nsamp,x1=x1,x2=x2,n1=n1,n2=n2,y=y[1:m,1],z=z[1:m,1]))<br>
}<br>
<br>
#Use R.A. Fisher's scoring algorithm to estimate phosi<br>
#phosi represents the intial guess on input<br>
get.estimates2&lt-function(phosi.init,x1,x2,n1,n2,y,z,lambda,ppbt,suppress){<br>
 Nsamp&lt-x1+x2<br>
 NTRIAL&lt-100<br>
 tolx&lt-1.e-5<br>
 nhatch&lt-length(phosi.init)<br>
 nhatch.orig&lt-nhatch<br>
 w&lt-y+z<br>
 nas&lt-rep(NA,nhatch)<br>
 phosi&lt-nas<br>
 phosi.var&lt-nas<br>
 phos&lt-NA<br>
 phos.var&lt-NA<br>
<br>
#in a rare case init can return zeroes even though the true estimate is not zero<br>
#which would defeat Fisher's scoring method<br>
jjj&lt-phosi.init==0<br>
phosi.init[jjj]&lt-phosi.init[jjj]+.00001<br>
#find zeroes that occur when lambda=0 and n1*lambda*ppbt+n2*(1-lambda)*ppbt>0<br>
jjj&lt-(n1*lambda*ppbt+n2*(1-lambda)*ppbt>0)&(lambda==0)&(w==0)<br>
if(sum(jjj)>=1){<br>
 y&lt-y[!jjj]<br>
 z&lt-z[!jjj]<br>
 ppbt&lt-ppbt[!jjj]<br>
 lambda&lt-lambda[!jjj]<br>
 phosi.init&lt-phosi.init[!jjj]<br>
 nhatch&lt-length(y)}<br>
<br>
#check for special cases<br>
#check to see if all VM releases PBT<br>
pbttest&lt-sum((ppbt-1)*lambda)==0<br>
#check to see if all lambdas are zero (special case)<br>
lambdatest&lt-sum(lambda==0)==nhatch<br>
<br>
#get the right Fisher Information function<br>
 if(lambdatest){<br>
  my.getI&lt-getI3<br>
  dlike&lt-dlike3<br>
 }<br>
 else{<br>
<br>
 if(pbttest){<br>
  my.getI&lt-getI2<br>
  dlike&lt-dlike2<br>
 }<br>
else{<br>
  my.getI&lt-getI<br>
  dlike&lt-dlike1<br>
 }<br>
 }<br>
<br>
#use R.A. Fisher's scoring algorithm to find where the partial derivatives of the <br>
#log-likelihood are zero. Use Fisher Information matrix in Newton's method to approx -Hessian<br>
 phosi&lt-phosi.init<br>
 errf&lt-0.0<br>
 alpha&lt-0.9<br>
 for(ii in 1:NTRIAL){<br>
  I&lt-my.getI(Nsamp,n1,n2,lambda,ppbt,phosi)<br>
  df&lt-dlike(phosi,x1,x2,n1,n2,y,z,lambda,ppbt)<br>
  size&lt-prod(dim(I))<br>
  if(size==0){<br>
    if(!suppress)warning(&quotdimension of I is 0 x 0&quot)<br>
    return(list(phosi=nas,phosi.var=nas,phos=NA,phos.var=NA))}<br>
  if(is.na(rcond(I))){<br>
    if(!suppress)warning(&quotcondition number of I is NA&quot)<br>
    return(list(phosi=nas,phosi.var=nas,phos=NA,phos.var=NA))}<br>
  if(rcond(I)&lt1.e-15){<br>
    if(!suppress)warning(&quotcomputationally singular information matrix&quot)<br>
    return(list(phosi=nas,phosi.var=nas,phos=NA,phos.var=NA))}<br>
  delx&lt-solve(I)%*%df<br>
  phosi&lt-phosi+delx*(1-alpha)<br>
  phosi&lt-abs(phosi)<br>
  errx&lt-sum(abs(delx))/sum(abs(phosi))<br>
  alpha&lt-alpha*alpha<br>
  if(errx&lt=tolx)break<br>
 }<br>
 if(ii==NTRIAL){<br>
  if(!suppress)warning(&quotmaximum number of iterations was reached&quot)<br>
  return(list(phosi=nas,phosi.var=nas,phos=NA,phos.var=NA))}<br>
 phos&lt-sum(phosi)<br>
 e&lt-rep(1,nhatch)<br>
 myvar&lt-solve(I)<br>
 phos.var&lt-t(e)%*%myvar%*%e<br>
 phosi.var&lt-diag(myvar)<br>
 full.phosi.var&lt-rep(0,nhatch.orig)<br>
 full.phosi&lt-rep(0,nhatch.orig)<br>
#recall that jjj represents hatcheries with estimates of phosi=0<br>
#reduction occurs only when sum(jjj>=1)<br>
 if(sum(jjj)>=1){<br>
  full.phosi.var[!jjj]&lt-phosi.var<br>
  full.phosi[!jjj]&lt-phosi<br>
 }<br>
 if(sum(jjj)&lt1){<br>
  full.phosi.var&lt-phosi.var<br>
  full.phosi&lt-phosi<br>
<br>
 }<br>
 return(list(phosi=full.phosi,phosi.var=full.phosi.var,phos=phos,phos.var=phos.var))<br>
}<br>
<br>
#get gradient of the log likelihood function<br>
#phosi is the current best estimate of phosi<br>
#used in most general case<br>
dlike1&lt-function(phosi,x1,x2,n1,n2,y,z,lambda,ppbt){<br>
#estimate phosi<br>
 Nsamp&lt-x1+x2<br>
 sum1&lt-sum(lambda*phosi)<br>
 sum2&lt-sum((1-ppbt)*lambda*phosi)<br>
 sum3&lt-sum(phosi*ppbt)<br>
 res&lt-lambda*(x1-n1)/sum1-lambda*(Nsamp-x1-n2)/(1-sum1)+y/phosi<br>
 res&lt-res+(n1-sum(y))*(1-ppbt)*lambda/sum2+z/phosi<br>
 res&lt-res-(n2-sum(z))*(lambda*(1-ppbt)+ppbt)/(1-sum2-sum3)<br>
 return(res)<br>
}<br>
<br>
#get gradient of the log likelihood function<br>
#phosi is the current best estimate of phosi<br>
#used in the case where sum(lambda*(1-ppbt))===0<br>
dlike2&lt-function(phosi,x1,x2,n1,n2,y,z,lambda,ppbt){<br>
#estimate phosi<br>
 Nsamp&lt-x1+x2<br>
 sum1&lt-sum(lambda*phosi)<br>
 sum3&lt-sum(phosi*ppbt)<br>
 res&lt-lambda*(x1-n1)/sum1-lambda*(Nsamp-x1-n2)/(1-sum1)+y/phosi<br>
 res&lt-res+z/phosi<br>
 res&lt-res-(n2-sum(z))*ppbt/(1-sum3)<br>
 return(res)<br>
}<br>
<br>
#get gradient of the log likelihood function<br>
#phosi is the current best estimate of phosi<br>
#used when lambda=0 at all hatcheries<br>
dlike3&lt-function(phosi,x1,x2,n1,n2,y,z,lambda,ppbt){<br>
#estimate phosi<br>
 Nsamp&lt-x1+x2<br>
 sum3&lt-sum(phosi*ppbt)<br>
 res&lt-z/phosi<br>
 res&lt-res-(n2-sum(z))*ppbt/(1-sum3)<br>
 return(res)<br>
}<br>
<br>
#get initial estimates of phosi<br>
#by equating x1,y,and z to their expectations<br>
#this yields 2*nhatch +1 equations with nhatch unknowns<br>
#which is, in general, overdetermined.<br>
init&lt-function(x1,x2,n1,n2,y,z,lambda,ppbt,suppress){<br>
Nsamp&lt-x1+x2<br>
nhatch&lt-length(lambda)<br>
A1&lt-lambda<br>
B1&lt-x1/Nsamp<br>
A2&lt--n1*diag(lambda*ppbt,ncol=nhatch,nrow=nhatch)<br>
LAMBDAMAT&lt-matrix(lambda,ncol=nhatch,nrow=nhatch)<br>
LAMBDAMAT&lt-t(LAMBDAMAT)<br>
YDIAG&lt-diag(y,nrow=nhatch,ncol=nhatch)<br>
ZDIAG&lt-diag(z,nrow=nhatch,ncol=nhatch)<br>
A2&lt-A2+YDIAG%*%LAMBDAMAT<br>
B2&lt-rep(0,nhatch)<br>
A3&lt-n2*diag((1-lambda)*ppbt,nrow=nhatch,ncol=nhatch)<br>
A3&lt-A3+ZDIAG%*%LAMBDAMAT<br>
B3&lt-z<br>
A&lt-rbind(A1,A2,A3)<br>
B&lt-c(B1,B2,B3)<br>
if(rcond(t(A)%*%A)&lt1.e-15){<br>
    if(!suppress)warning(&quotmatrix t(A)%A in init() is computationally singular&quot)}<br>
phosi&lt-solve(t(A)%*%A)%*%t(A)%*%B<br>
return(abs(phosi))<br>
}<br>
</div>

</div>
</div>
<div class="hide" id="tab3">
<a name="info_top"></a>
  <div class="info_text">
	<p>Here are some basic tips for using this tool. Choose from the topics below.</p>
		<ul>
		<li><a href="#info_choosing" class="tablink">Choosing Input Parameter Values</a></li>
		<li><a href="#info_calc" class="tablink">Obtaining Results</a></li>
		<li><a href="#info_interpret" class="tablink">Interpreting Results</a></li>
		<li><a href="#info_export" class="tablink">Exporting Data</a></li>
		<li><a href="#info_charts" class="tablink">Working With Charts</a></li>
		</ul>	
		
		<br>
		<a name="info_choosing"/>
		<span class="info_header">Choosing Input Parameter Values</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>
		<table border="1" cellmargin="2" class="users_guide_table" cellpadding="5">
		<tr><td align="top" valign="left" width="200"><p><b>Proportion of hatchery-origin spawners (phosi)</b></p></td><td align="top" valign="left"><p>True proportions of hatchery-origin spawners. Value must be between zero and one, one (hatchery) value per line.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>Number of samples (NSamp)</b></p></td><td align="top" valign="left"><p>Total number of spawners sampled on spawning grounds.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>Total subsample size (n)</b></p></td><td align="top" valign="left"><p>The total number of samples tested for parentage-based tagging (PBT).</p></td></tr>
		<tr><td align="top" valign="left"><p><b>Marked subsample size (n1)</b></p></td><td align="top" valign="left"><p>The number of marked samples tested for parentage-based tagging (PBT).</p></td></tr>
		<tr><td align="top" valign="left"><p><b>Optimize marked subsample size</b></p></td><td align="top" valign="left"><p>If checked, adjusts n1 so as to minimize the standard error of the estimator of the proportion of hatchery-origin spawners (SE_phos) for a fixed subsample size n.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>Marking fractions (lambda)</b></p></td><td align="top" valign="left"><p>The marking fractions. Enter numbers between zero and one, one (hatchery) value per line.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>PBT fractions (ppbt)</b></p></td><td align="top" valign="left"><p>The Parentage-based taging (PBT) Fraction. Enter a number between 0 and 1, one (hatchery) value per line.</p></td></tr>		
		<tr><td align="top" valign="left"><p><b>Analytical</b></p></td><td align="top" valign="left"><p>Choose this option when the total spawners is sufficiently large so that the asymptotic large-sample properties hold for the formulae for SE and CV for the proportion of hatchery-origin spawners (phos). To determine what total spawner values are sufficient to accurately estimate SE and CV for phos, compare the analytical results to the Monte Carlo results. The Monte Carlo results do not depend on large-sample properties.</p></td></tr>		
		<tr><td align="top" valign="left"><p><b>Monte Carlo</b></p></td><td align="top" valign="left"><p>Choose this option when the total number of spawners is small and asymptotic large-sample properties assumed in the SE and CV for the proportion of hatchery-origin spawners (phos) do not hold. Increasing the number of simulations will increase the accuracy of the output SE and CV values. Experiment with the number of simulations until the desired accuracy is achieved.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>Number of simulations (NSIM)</b></p></td><td align="top" valign="left"><p>The number of simulations used in the Monte Carlo calculation method. Greater accuracy in the calculation of SE, CV, and bias may be obtained by increasing NSIM.</p></td></tr>		
		</table>
	
		<br>
		<a name="info_calc"/>
		<span class="info_header">Obtaining Results</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>
		<p>To calculate results for a given set of input parameters, click on the <b>Calculate</b> button in the lower left corner. A row will be added to the data table to the right.
		</p><p>
		To clear the values from the table, click on the <b>Clear</b> button.
		</p>
	
		<br>
		<a name="info_interpret"/>
		<span class="info_header">Interpreting Results</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>	
		<p>Output parameters are those displayed on the right side of the results table (unshaded cells).</p>
		<table border="1" cellmargin="2" class="users_guide_table" cellpadding="5">
		<tr><td align="top" valign="left"><p><b>phos</b></p></td><td align="top" valign="left"><p>The true proportion of hatchery-origin spawners.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>Ex1</b></p></td><td align="top" valign="left"><p>The expected number of spawners in the sample of size Nsamp that are visibly marked.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>Ex2</b></p></td><td align="top" valign="left"><p>The expected number of spawners in the sample of size Nsamp that are not visibly marked.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>SE_MIN</b></p></td><td align="top" valign="left"><p>The SE of the estimator of the proportion of hatchery origin spawners when the entire sample of size Nsamp is tested for PBT.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>CV_MIN</b></p></td><td align="top" valign="left"><p>The CV of the estimator of the proportion of hatchery origin spawners when the entire sample of size Nsamp is  tested for PBT.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>SE_phos</b></p></td><td align="top" valign="left"><p>The standard error of the estimator of the proportion of hatchery-origin spawners.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>CV_phos</b></p></td><td align="top" valign="left"><p>The coefficient of variation of the estimator of the proportion of hatchery-origin spawners.</p></td></tr>
		<tr><td align="top" valign="left"><p><b>BIAS_phos</b></p></td><td align="top" valign="left"><p>Relative bias of the proportion of hatchery-origin spawners</p></td></tr>
		</table>
		
		<br>
		<a name="info_export"/>
		<span class="info_header">Exporting Data</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>		
		<p>To export data, click the Export button. The data currently in the results table will be downloaded to your computer in comma-separated value (CSV) format. You may need to set your browser to recognize the .csv filetype and associate it with a program such as Excel.</p>
		<br>
		<a name="info_charts"/>
		<span class="info_header">Working With Charts</a> <a href="#info_top"><img src="../images/up_arrow.jpg" border="0"></a></span>	
		<p>A common use of the tool is to study the effect of changing one input on one or more outputs in the calculation. Exporting the data for further analysis or presentation (as above) is one option, but as it is useful to get immediate feedback, real-time charting is provided.</p>
		<p>Charts provide an instant graphical display of the results of calculations. After at least two calculations are performed, the results are automatically plotted on the chart as an x-y scatterplot.  The following terms are useful in understanding the use and functionality of the Charts:</p>
		<ul>
		<li><i>Data Series</i><br/>
		A data series consists of a set of (two or more) calculations performed wherein <u>one</u> input parameter is varied</li>
		<li><i>Chart</i><br/>
		<p>The chart displays one or more data series with one of two plot types, depending on the input parameter chosen as the x-axis. For single-valued parameters, an x-y scatterplot is displayed, with the points optionally connected with lines. The x-axis should be the one varied across the data series (different for each calculation). The y-axis can be any of the output values. There is some functionality for customizing the chart.
		For multi-valued input parameters (i.e. where there is an entry for each hatchery), the chart displays the calculation results in the order performed, left to right, with the output value indicated along the x-axis as a short horizontal marker. There is no assumed relation (e.g. linear, etc.) of the different output values, and the values cannot be connected with lines.</p> 
		<p>Since any combination of hatchery-specific values can be chosen for each calculation, there is no general way for the charting routine to logically order the values (create an x-y scatterplot). It is thus up to the user to choose a set of inputs which makes sense for display purposes.</p>
		</li>
		<li><i>Chart Gallery</i><br/>
		The Chart Gallery provides a way to save various charts generated as you work for immediate comparison as well as making it possible to save each chart as an image to your computer.</li>
		</ul>
		
		<p>The best way to understand the function and capabilities of Charts is to walk through a typical scenario: <br/>We are interested primarily in the effect on the calculation result of changing one of the input parameters, and secondarily in the effect of changing yet another. Although we are specifically interested in the behaviour of one output parameter, 
		<ol>
		<li>Set initial input values, and then select one to sequentially modify.</li>
		<li>In the Chart Settings, assign the x-axis variable to the one selected above. Set the y-axis variable to whichever is of primary interest (not critical, as it can be changed later).</li>
		<li>Click the "Calculate" button. The result is added to the output table.</li>
		<li>Modify the primary input parameter (i.e. increment or decrement by some amount). Click the "Calculate" button. The result is added to the output table, and an x-y scatterplot is drawn showing both the current and the previous data points (optionally connected by a line). The scale of the plot automatically adjusts based on all values plotted.</li>
		<li>Repeat the last step as necessary to fully characterize the response.</li>
		<li>Add a title for the chart, and a label for the current data series. Click on the text box for each, type in the label, and then click outside the box to enable the change.</li>
		<li>At this point, you may choose to save the chart to the Chart Gallery. Click the "Add" button at bottom. The Gallery is opened with the current (right now, the only) chart on top. This is identical in appearance to what was previously visible, but is also a regular web graphic. You may right-click on this image to copy to clipboard or save to your computer. Close the Gallery when finished.</li>
		<li>We are interested in seeing the same results plotted using a different output parameter. Select a different value for y-axis variable in the Chart Settings. The chart is instantly updated. Add this to the gallery by clicking the "Add" button, and the Gallery opens with both the current and the previous charts visible (scroll down to see the previous). Close the Gallery.</li>
		<li>Now let's redo the calculations but with a change to a second input. First <b>(important!)</b> click the "+" button in the Chart Settings. This closes out the first data series and adds a second. Any subsequent calculations are assigned to this new data series.</li>
		<li>Repeat steps 4-5 above using the same set of primary input parameters, but with the secondary parameter given a new value. Each new result gets added, and the chart is redrawn to display all data from all data sets. Each data set is assigned a different color, and a legend is drawn which identifies them by label. The position of the legend can be selected (or hidden) in the Chart Settings</li>
		<li>After this, you have the option of saving to the Chart Gallery, adding more data series, or starting over with new data series. To do the latter, click the "Clear" button. <b>Note:</b> this also clears the Chart Gallery, so save any charts to your computer (i.e. using right-click and "Save As") before clearing.</li>
		</ol>
	  </div>
	</div>
	<div class="hide" id="tab4">
	  <div class="info_text">
		<strong>Methodology and mathematical derivation:</strong>
		<ul>
		<li>
		Richard Hinrichsen, Ph.D., Hinrichsen Environmental Consulting<br>
		<a href="mailto:rich@hinrichsenenvironmental.com">rich@hinrichsenenvironmental.com</a>
		</li>
		</ul>
		<strong>Tool programming and web development:</strong>
		<ul>
		<li>
		Brian Maschhoff, Ph.D., Salmonetics<br>
		<a href="mailto:brianm@salmonetics.com">brianm@salmonetics.com</a><br><br>
		</li></ul>
		<strong>Acknowledgement:</strong><br>We gratefully acknowledge the support of Bonneville Power Administration<br> in the development of this web tool.
	</div>	
  </div>
</div>


<!-- Site Meter -->
<a href="http://s33.sitemeter.com/stats.asp?site=s33onefishtwofish" target="_new">
<img src="http://s33.sitemeter.com/meter.asp?site=s33onefishtwofish" alt="Site Meter" border="0"/></a>
<!-- Copyright (c)2009 Site Meter -->
</body>
</html>


